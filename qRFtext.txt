runranger_quant_default=function(Y,indice,lag){
  comp=princomp(scale(Y,scale=FALSE))
  Y2=cbind(Y,comp$scores[,1:4])
  aux=embed(Y2,4+lag)
  y=aux[,indice]
  X=aux[,-c(1:(ncol(Y2)*lag))]  
  
  if(lag==1){
    #added drop=FALSE because there is only one row in the tail
    #and subsetting matrices automatically removes dimensions of length 1 int he resulting object
    #This ensures that X.out is matrix with one row. Not a vector.
    X.out=tail(aux,1)[,1:ncol(X), drop= FALSE] 
  }else{
    #added drop=FALSE because there is only one row in the tail
    #and subsetting matrices automatically removes dimensions of length 1 int he resulting object
    #This ensures that X.out is matrix with one row. Not a vector.
    
    X.out=aux[,-c(1:(ncol(Y2)*(lag-1)))]
    X.out=tail(X.out,1)[,1:ncol(X), drop= FALSE]
  }
  
  # y = y[1:(length(y)-lag+1)]
  X.out=tail(aux,1)[1:ncol(X)]  # X = X[1:(nrow(X)-lag+1),]
  
  # print("line 24")
  
  model <- ranger( y =  y, x = as.data.frame(X), 
                   quantreg = TRUE,
                   importance = 'impurity')
  
  # print("line 42")
  
  predtemp <- predict(model, as.data.frame(X.out), type = "quantiles", quantiles = c(0.025,0.5,0.975))$predictions
  pred <-predtemp[,2]
  
  #it is also possible to use the predict function with BART
  #pred=predict(model,X.out)
  ## select 10 equally spaced individuals
  
  #ideally would not have to take first column
  #this is the result of a bug in the wbart functioon in the BART package
  #yhat.test should be a matrix with one column, but instead the number of columns equals the number of observations
  #the authors of the BART package have been notified and this will be fixed in the next release of the package on CRAN
  # test_mcmcsamps <- model$yhat.test[,1]
  # sigmadraws <- model$sigma
  # 
  
  #prediction intervals
  
  #first, must draw outcomes instead of just using conditional means in test_mcmcsamps
  #for each row, take samples
  # test_y_samps <- matrix(NA, nrow = nrow(test_mcmcsamps),ncol = ncol(test_mcmcsamps))
  
  #vector instead of matrix due to bug outlined above
  # test_y_samps <- rep(NA, length(test_mcmcsamps)) #matrix(NA, nrow = nrow(test_mcmcsamps),ncol = ncol(test_mcmcsamps))
  
  #iterate over draws (each row of test_mcmcsamps is an mcmc draw)
  #test_mcmcsamps[i,] is vector of conditional means for model draw i
  #sigmadraws[i] is draw of standard deviation of error for model i
  
  # for(i in 1:nrow(test_mcmcsamps)){
  #   test_y_samps[i,] <- rnorm(n = ncol(test_mcmcsamps), 
  #                             mean = test_mcmcsamps[i,],
  #                             sd = sigmadraws[i])
  # }
  
  # for(i in 1:length(test_mcmcsamps)){
  #   test_y_samps[i] <- rnorm(n=1,
  #                            mean = test_mcmcsamps[i],
  #                            sd = sigmadraws[i])
  # }
  
  
  #columns correspond to individuals
  #obtain the 2.5% and 97.5% quantiles for each column
  
  #taking the transpose so that first column is vector of 2.5% values for each individual
  #second column is a vector of 97.5 values for each individual
  # pred_intervals <- t(apply(test_y_samps, 2, quantile, probs = c(0.025, 0.975)))
  
  #only one prediction, so perhaps unnecessary to save as matrix instead of column
  
  pred_intervals <- t(c(predtemp[,1],predtemp[,3]) )
  
  # print("line 73")
  
  #MCMC convergence diagnostics
  #convergence of draws of conditional mean for test observation
  # post.mcmc <- test_mcmcsamps[ , 1]
  # post.mcmc <- test_mcmcsamps
  # print("line 77")
  # geweke_bart_testpreds <- gewekediag(post.mcmc)$z
  
  # geweke_bart_testpreds <- gewekediag(as.matrix(test_mcmcsamps))$z
  
  #convergence of draws of sigma
  # print("line 73")
  
  # geweke_bart_sigma <- gewekediag(as.matrix(sigmadraws))$z
  
  
  return(list("model"= model,
              "pred"= pred,
              "pred_intervals" = pred_intervals#,
              # "geweke_bart_testpreds"= geweke_bart_testpreds,
              # "geweke_bart_sigma" = geweke_bart_sigma
  ))
}


ranger_quant_default.rolling.window=function(Y,nprev,indice=1,lag=1){
  
  save.importance=list()
  #posterior inclusion probabilities can also be used as variable importance measues
  save.pip=list()
  save.pred=matrix(NA,nprev,1)
  
  
  save.pred_intervals = matrix(NA,nprev,2)
  
  # save.geweke_bart_testpreds = matrix(NA,nprev,1)
  # save.geweke_bart_sigma = matrix(NA,nprev,1)
  # 
  # i <- nprev
  
  #code for parallelization
  
  
  
  
  #for(i in nprev:1){
  myfunction <- function(i) {
    library(ranger)
    
    res_temp <- list()
    
    window_len <- nrow(Y)-nprev-12; Tplush <- nrow(Y)+1-i ; endwind <- Tplush-lag ;  beginwind <- endwind-window_len ; Y.window=Y[(1+nprev-i):endwind,]
    #original medeiros et al. code uses "lasso" here to refer to all models
    
    # print("line 149")
    lasso=runranger_quant_default(Y.window,indice,lag)
    
    # print("line 152")
    
    
    
    #SAVE PREDICTIONS
    #this should be included for all methods
    res_temp$save.pred=lasso$pred
    
    #SAVE PREDICTION INTERVALS
    #not all methods include prediciton intervals
    #ensure that all prediction intervals are saved in the same format for all methods
    res_temp$save.pred_intervals=lasso$pred_intervals
    
    
    #SAVE MCMC DIAGNOSTICS
    #onlyapplicable to methods that use MCMC
    
    # res_temp$save.geweke_bart_testpreds=lasso$geweke_bart_testpreds
    # res_temp$save.geweke_bart_sigma=lasso$geweke_bart_sigma
    
    
    #SAVE VARIABLE IMPORTANCE RESULTS
    #Note: This is specific to the methods
    #Different methods have different variable importance measures
    #some methods have no variable importance measures
    #some methods have more than one variable importance measure
    
    # temp_varcounts <- lasso$model$variable.importance
    #BART variable inclusion probabilities as defined by Chipman et al
    #For each sum-of-tree model, obtain the proportions of splits for each variable
    #then average this across mcmc draws of sum-of-tree models
    
    res_temp$save.importance = lasso$model$variable.importance #colMeans((temp_varcounts/rowSums(temp_varcounts)))
    
    #the posterior inclusion probabilities are averages across model draws of 
    #indicators for whether the variable was used for any splits in the sum-of-tree model
    # res_temp$save.pip = colMeans(1*(temp_varcounts>0))
    
    #cat("iteration",(1+nprev-i),"\n")
    
    
    return(res_temp)
    
    
  }
  
  
  
  # no_cores <- detectCores(logical = TRUE)  # returns the number of available hardware threads, and if it is FALSE, returns the number of physical cores
  
  cl <- makeCluster(120)
  clusterSetRNGStream(cl = cl, iseed = 123)
  
  clusterExport(cl,c('myfunction',
                     'nprev',
                     'indice',
                     'lag',
                     'Y',
                     'runranger_quant_default'
  ),
  envir = environment()
  )
  
  #registerDoParallel(cl)
  
  
  # start.time <- Sys.time()
  
  res_list <- parallel::parLapply(cl = cl, 1:nprev, fun = myfunction)
  
  stopCluster(cl)
  
  # end.time <- Sys.time()
  # time.taken <- end.time - start.time
  # time.taken
  
  for (i in nprev:1){
    
    save.pred[(1+nprev-i),]=res_list[[i]]$save.pred
    save.pred_intervals[(1+nprev-i),]=res_list[[i]]$save.pred_intervals
    # save.geweke_bart_testpreds[(1+nprev-i),]=res_list[[i]]$save.geweke_bart_testpreds
    # save.geweke_bart_sigma[(1+nprev-i),]=res_list[[i]]$save.geweke_bart_sigma
    save.importance[[i]] =res_list[[i]]$save.importance
    # save.pip[[i]] = res_list[[i]]$save.pip
    
    
  }
  
  
  
  
  real=Y[,indice]
  
  #these lines seem pointless, commenting out
  # plot(real,type="l")
  # lines(c(rep(NA,length(real)-nprev),save.pred),col="red")
  
  rmse=sqrt(mean((tail(real,nprev)-save.pred)^2))
  mae=mean(abs(tail(real,nprev)-save.pred))
  
  #median absolute deviation from the median in paper, but not in code
  mad = median(abs(tail(real,nprev)-save.pred - median(tail(real,nprev)-save.pred)))
  
  #mean absolute deviation from  he mean
  mean_ad = mean(abs(tail(real,nprev)-save.pred - mean(tail(real,nprev)-save.pred)))
  
  
  #mean relative absolute error (relative to random walk)
  #last 132 lagged one month values are
  #real[(nrow(dados)-nprev):(nrow(dados)-1)]
  mrae = mean(abs( (tail(real,nprev)-save.pred)/
                     (tail(real,nprev)-real[(nrow(dados)-nprev):(nrow(dados)-1)]  )     ))
  
  #mean absolute scaled error
  #equivalent to mae of method divided by nae of naive forecast
  #first calculate the denomiator
  #mean of vector of length nprev-1
  tempdenom = mean( abs(tail(real,nprev-1) - real[(nrow(dados)-nprev+1):(nrow(dados)-1)]  ) )
  #then the overall measure is
  mase=mae/tempdenom
  
  #mean absolute percentage error
  mape = (100/nprev)*mean(abs((tail(real,nprev)-save.pred)/tail(real,nprev)))
  
  #normalized rmse
  nrmse = rmse/(max(tail(real,nprev))-min(tail(real,nprev)))
  
  #rmse relative to random walk
  
  #rmse of naive rw forecast
  rwrmse=sqrt(mean((tail(real,nprev)-real[(nrow(dados)-nprev):(nrow(dados)-1)])^2))
  
  rmse_rel_rw = rmse/rwrmse
  
  
  errors=c("rmse"=rmse,
           "mae"=mae,
           "mad"=mad,
           "mean_ad"=mean_ad,
           "mrae"=mrae,
           "mase"=mase,
           "mape"=mape,
           "nrmse"=nrmse,
           "rmse_rel_rw"=rmse_rel_rw)
  
  #mean prediction interval coverage
  predint_cov = mean( 1*((save.pred_intervals[,1] < tail(real,nprev))  & (tail(real,nprev) < save.pred_intervals[,2])   ))
  
  #mean prediction interval width
  predint_width = mean(save.pred_intervals[,2] - save.pred_intervals[,1])
  
  
  
  
  
  
  
  return(list("pred"= save.pred,
              "errors"= errors,
              # "save.pred_intervals"= save.pred_intervals,
              #"save.geweke_bart_testpreds"= save.geweke_bart_testpreds,
              #"save.geweke_bart_sigma"= save.geweke_bart_sigma,
              "save.importance"= save.importance ,
              # "save.pip"= save.pip,
              "predint_cov"= predint_cov,
              "predint_width"= predint_width
  ))
  
}

source("func-ranger-quant-default.R")
library(HDeconometrics)
# library(ranger)
library(doParallel)
library(parallel)


load("rawdata.rda")
Y=dados

nprev=132


## == presente == ##
set.seed(123)
ranger_quant_default_1c=ranger_quant_default.rolling.window(Y,nprev,1,1)
ranger_quant_default_1p=ranger_quant_default.rolling.window(Y,nprev,2,1)
ranger_quant_default_2c=ranger_quant_default.rolling.window(Y,nprev,1,2)
ranger_quant_default_2p=ranger_quant_default.rolling.window(Y,nprev,2,2)
ranger_quant_default_3c=ranger_quant_default.rolling.window(Y,nprev,1,3)
ranger_quant_default_3p=ranger_quant_default.rolling.window(Y,nprev,2,3)
ranger_quant_default_4c=ranger_quant_default.rolling.window(Y,nprev,1,4)
ranger_quant_default_4p=ranger_quant_default.rolling.window(Y,nprev,2,4)
ranger_quant_default_5c=ranger_quant_default.rolling.window(Y,nprev,1,5)
ranger_quant_default_5p=ranger_quant_default.rolling.window(Y,nprev,2,5)
ranger_quant_default_6c=ranger_quant_default.rolling.window(Y,nprev,1,6)
ranger_quant_default_6p=ranger_quant_default.rolling.window(Y,nprev,2,6)
ranger_quant_default_7c=ranger_quant_default.rolling.window(Y,nprev,1,7)
ranger_quant_default_7p=ranger_quant_default.rolling.window(Y,nprev,2,7)
ranger_quant_default_8c=ranger_quant_default.rolling.window(Y,nprev,1,8)
ranger_quant_default_8p=ranger_quant_default.rolling.window(Y,nprev,2,8)
ranger_quant_default_9c=ranger_quant_default.rolling.window(Y,nprev,1,9)
ranger_quant_default_9p=ranger_quant_default.rolling.window(Y,nprev,2,9)
ranger_quant_default_10c=ranger_quant_default.rolling.window(Y,nprev,1,10)
ranger_quant_default_10p=ranger_quant_default.rolling.window(Y,nprev,2,10)
ranger_quant_default_11c=ranger_quant_default.rolling.window(Y,nprev,1,11)
ranger_quant_default_11p=ranger_quant_default.rolling.window(Y,nprev,2,11)
ranger_quant_default_12c=ranger_quant_default.rolling.window(Y,nprev,1,12)
ranger_quant_default_12p=ranger_quant_default.rolling.window(Y,nprev,2,12)


#MCS test across horizons


# 
# ranger_quant_default_6c$errors
# 
# ranger_quant_default_6c$predint_cov
# 
# cbind(tail(Y[,1],132),ranger_quant_default_6c$pred )

### == juntando tudo ==  ###

cpi=cbind(ranger_quant_default_1c$pred,ranger_quant_default_2c$pred,ranger_quant_default_3c$pred,ranger_quant_default_4c$pred,
          ranger_quant_default_5c$pred,ranger_quant_default_6c$pred,ranger_quant_default_7c$pred,ranger_quant_default_8c$pred,
          ranger_quant_default_9c$pred,ranger_quant_default_10c$pred,ranger_quant_default_11c$pred,ranger_quant_default_12c$pred)

pce=cbind(ranger_quant_default_1p$pred,ranger_quant_default_2p$pred,ranger_quant_default_3p$pred,ranger_quant_default_4p$pred,
          ranger_quant_default_5p$pred,ranger_quant_default_6p$pred,ranger_quant_default_7p$pred,ranger_quant_default_8p$pred,
          ranger_quant_default_9p$pred,ranger_quant_default_10p$pred,ranger_quant_default_11p$pred,ranger_quant_default_12p$pred)


##
write.table(cpi,"./results/passado2000_fixed_oldstart/ranger-quant-default-cpi.csv",sep=";",row.names = FALSE, col.names = FALSE)
write.table(pce,"./results/passado2000_fixed_oldstart/ranger-quant-default--pce.csv",sep=";",row.names = FALSE, col.names = FALSE)

#save all the results, including intervals etc
save(ranger_quant_default_1c,ranger_quant_default_2c,ranger_quant_default_3c,ranger_quant_default_4c,
     ranger_quant_default_5c,ranger_quant_default_6c,ranger_quant_default_7c,ranger_quant_default_8c,
     ranger_quant_default_9c,ranger_quant_default_10c,ranger_quant_default_11c,ranger_quant_default_12c ,
     file = "./results/passado2000_fixed_oldstart/ranger-quant-default-all-cpi.Rdata")


ranger_cpi_list <- list(ranger_quant_default_1c,ranger_quant_default_2c,ranger_quant_default_3c,ranger_quant_default_4c,
                        ranger_quant_default_5c,ranger_quant_default_6c,ranger_quant_default_7c,ranger_quant_default_8c,
                        ranger_quant_default_9c,ranger_quant_default_10c,ranger_quant_default_11c,ranger_quant_default_12c)

save(ranger_cpi_list ,file =  "./results/passado2000_fixed_oldstart/ranger-quant-default-list-cpi.Rdata")


ranger_pce_list <- list(ranger_quant_default_1p,ranger_quant_default_2p,ranger_quant_default_3p,ranger_quant_default_4p,
                        ranger_quant_default_5p,ranger_quant_default_6p,ranger_quant_default_7p,ranger_quant_default_8p,
                        ranger_quant_default_9p,ranger_quant_default_10p,ranger_quant_default_11p,ranger_quant_default_12p)

save(ranger_pce_list , file = "./results/passado2000_fixed_oldstart/ranger-quant-default-list-pce.Rdata")
