runrf_parallel=function(Y,indice,lag){
  comp=princomp(scale(Y,scale=FALSE))
  Y2=cbind(Y,comp$scores[,1:4])
  aux=embed(Y2,4+lag)
  y=aux[,indice]
  X=aux[,-c(1:(ncol(Y2)*lag))]  
  
  if(lag==1){
    #added drop=FALSE because there is only one row in the tail
    #and subsetting matrices automatically removes dimensions of length 1 int he resulting object
    #This ensures that X.out is matrix with one row. Not a vector.
    X.out=tail(aux,1)[,1:ncol(X), drop= FALSE] 
  }else{
    #added drop=FALSE because there is only one row in the tail
    #and subsetting matrices automatically removes dimensions of length 1 int he resulting object
    #This ensures that X.out is matrix with one row. Not a vector.
    
    X.out=aux[,-c(1:(ncol(Y2)*(lag-1)))]
    X.out=tail(X.out,1)[,1:ncol(X), drop= FALSE]
  }
  
  # y = y[1:(length(y)-lag+1)]
  X.out=tail(aux,1)[1:ncol(X)]  # X = X[1:(nrow(X)-lag+1),]
  
  # print("line 24")
  
  model=randomForest(X,y,importance=TRUE)
  pred=predict(model,X.out)
  # print("line 42")
  

  
  #MCMC convergence diagnostics
  #convergence of draws of conditional mean for test observation
  # post.mcmc <- test_mcmcsamps[ , 1]
  # post.mcmc <- test_mcmcsamps
  # print("line 77")
  # geweke_bart_testpreds <- gewekediag(post.mcmc)$z
  
  # geweke_bart_testpreds <- gewekediag(as.matrix(test_mcmcsamps))$z
  
  #convergence of draws of sigma
  # print("line 73")
  
  # geweke_bart_sigma <- gewekediag(as.matrix(sigmadraws))$z
  
  
  return(list("model"= model,
              "pred"= pred#,
              # "pred_intervals" = pred_intervals#,
              # "geweke_bart_testpreds"= geweke_bart_testpreds,
              # "geweke_bart_sigma" = geweke_bart_sigma
  ))
}


rf_parallel.rolling.window=function(Y,nprev,indice=1,lag=1){
  
  save.importance=list()
  #posterior inclusion probabilities can also be used as variable importance measues
  save.pip=list()
  save.pred=matrix(NA,nprev,1)
  
  
  save.pred_intervals = matrix(NA,nprev,2)
  
  save.geweke_bart_testpreds = matrix(NA,nprev,1)
  save.geweke_bart_sigma = matrix(NA,nprev,1)
  
  # i <- nprev
  
  #code for parallelization
  
  
  
  
  #for(i in nprev:1){
  myfunction <- function(i) {
    library(randomForest)
    
    res_temp <- list()
    
    window_len <- nrow(Y)-nprev-12; Tplush <- nrow(Y)+1-i ; endwind <- Tplush-lag ;  beginwind <- endwind-window_len ; Y.window=Y[(1+nprev-i):endwind,]
    #original medeiros et al. code uses "lasso" here to refer to all models
    
    # print("line 149")
    lasso=runrf_parallel(Y.window,indice,lag)
    
    # print("line 152")
    
    
    
    #SAVE PREDICTIONS
    #this should be included for all methods
    res_temp$save.pred=lasso$pred
    
    #SAVE PREDICTION INTERVALS
    #not all methods include prediciton intervals
    #ensure that all prediction intervals are saved in the same format for all methods
    # res_temp$save.pred_intervals=lasso$pred_intervals
    
    
    #SAVE MCMC DIAGNOSTICS
    #onlyapplicable to methods that use MCMC
    
    # res_temp$save.geweke_bart_testpreds=lasso$geweke_bart_testpreds
    # res_temp$save.geweke_bart_sigma=lasso$geweke_bart_sigma
    
    
    #SAVE VARIABLE IMPORTANCE RESULTS
    #Note: This is specific to the methods
    #Different methods have different variable importance measures
    #some methods have no variable importance measures
    #some methods have more than one variable importance measure
    
    # temp_varcounts <- lasso$model$varcount
    #BART variable inclusion probabilities as defined by Chipman et al
    #For each sum-of-tree model, obtain the proportions of splits for each variable
    #then average this across mcmc draws of sum-of-tree models
    
    res_temp$save.importance = lasso$model$importance[,1] #colMeans((temp_varcounts/rowSums(temp_varcounts)))
    
    #the posterior inclusion probabilities are averages across model draws of 
    #indicators for whether the variable was used for any splits in the sum-of-tree model
    # res_temp$save.pip = colMeans(1*(temp_varcounts>0))
    
    #cat("iteration",(1+nprev-i),"\n")
    
    
    return(res_temp)
    
    
  }
  
  
  
  no_cores <- detectCores(logical = TRUE)  # returns the number of available hardware threads, and if it is FALSE, returns the number of physical cores
  
  cl <- makeCluster(no_cores-1)
  clusterSetRNGStream(cl = cl, iseed = 123)
  
  clusterExport(cl,c('myfunction',
                     'nprev',
                     'indice',
                     'lag',
                     'Y',
                     'runrf_parallel'
  ),
  envir = environment()
  )
  
  #registerDoParallel(cl)
  
  
  # start.time <- Sys.time()
  
  res_list <- parallel::parLapply(cl = cl, 1:nprev, fun = myfunction)
  
  stopCluster(cl)
  
  # end.time <- Sys.time()
  # time.taken <- end.time - start.time
  # time.taken
  
  for (i in nprev:1){
    
    save.pred[(1+nprev-i),]=res_list[[i]]$save.pred
    # save.pred_intervals[(1+nprev-i),]=res_list[[i]]$save.pred_intervals
    # # save.geweke_bart_testpreds[(1+nprev-i),]=res_list[[i]]$save.geweke_bart_testpreds
    # # save.geweke_bart_sigma[(1+nprev-i),]=res_list[[i]]$save.geweke_bart_sigma
    save.importance[[i]] =res_list[[i]]$save.importance
    # save.pip[[i]] = res_list[[i]]$save.pip
    
    
  }
  
  
  
  
  real=Y[,indice]
  
  #these lines seem pointless, commenting out
  # plot(real,type="l")
  # lines(c(rep(NA,length(real)-nprev),save.pred),col="red")
  
  rmse=sqrt(mean((tail(real,nprev)-save.pred)^2))
  mae=mean(abs(tail(real,nprev)-save.pred))
  
  #median absolute deviation from the median in paper, but not in code
  mad = median(abs(tail(real,nprev)-save.pred - median(tail(real,nprev)-save.pred)))
  
  #mean absolute deviation from  he mean
  mean_ad = mean(abs(tail(real,nprev)-save.pred - mean(tail(real,nprev)-save.pred)))
  
  
  #mean relative absolute error (relative to random walk)
  #last 132 lagged one month values are
  #real[(nrow(dados)-nprev):(nrow(dados)-1)]
  mrae = mean(abs( (tail(real,nprev)-save.pred)/
                     (tail(real,nprev)-real[(nrow(dados)-nprev):(nrow(dados)-1)]  )     ))
  
  #mean absolute scaled error
  #equivalent to mae of method divided by nae of naive forecast
  #first calculate the denomiator
  #mean of vector of length nprev-1
  tempdenom = mean( abs(tail(real,nprev-1) - real[(nrow(dados)-nprev+1):(nrow(dados)-1)]  ) )
  #then the overall measure is
  mase=mae/tempdenom
  
  #mean absolute percentage error
  mape = (100/nprev)*mean(abs((tail(real,nprev)-save.pred)/tail(real,nprev)))
  
  #normalized rmse
  nrmse = rmse/(max(tail(real,nprev))-min(tail(real,nprev)))
  
  #rmse relative to random walk
  
  #rmse of naive rw forecast
  rwrmse=sqrt(mean((tail(real,nprev)-real[(nrow(dados)-nprev):(nrow(dados)-1)])^2))
  
  rmse_rel_rw = rmse/rwrmse
  
  
  errors=c("rmse"=rmse,
           "mae"=mae,
           "mad"=mad,
           "mean_ad"=mean_ad,
           "mrae"=mrae,
           "mase"=mase,
           "mape"=mape,
           "nrmse"=nrmse,
           "rmse_rel_rw"=rmse_rel_rw)
  
  # #mean prediction interval coverage
  # predint_cov = mean( 1*((save.pred_intervals[,1] < tail(real,nprev))  & (tail(real,nprev) < save.pred_intervals[,2])   ))
  # 
  # #mean prediction interval width
  # predint_width = mean(save.pred_intervals[,2] - save.pred_intervals[,1])
  # 
  
  
  
  
  
  
  return(list("pred"= save.pred,
              "errors"= errors,
              # "save.pred_intervals"= save.pred_intervals,
              #"save.geweke_bart_testpreds"= save.geweke_bart_testpreds,
              #"save.geweke_bart_sigma"= save.geweke_bart_sigma,
              "save.importance"= save.importance#,
              # "save.pip"= save.pip,
              # "predint_cov"= predint_cov,
              # "predint_width"= predint_width
              ))
  
}

source("func-rf-parallel.R")
library(HDeconometrics)
# library(BART)
library(doParallel)
library(parallel)


load("rawdata.rda")
Y=dados

nprev=132


## == presente == ##
set.seed(123)
rf_parallel_1c=rf_parallel.rolling.window(Y,nprev,1,1)
rf_parallel_1p=rf_parallel.rolling.window(Y,nprev,2,1)
rf_parallel_2c=rf_parallel.rolling.window(Y,nprev,1,2)
rf_parallel_2p=rf_parallel.rolling.window(Y,nprev,2,2)
rf_parallel_3c=rf_parallel.rolling.window(Y,nprev,1,3)
rf_parallel_3p=rf_parallel.rolling.window(Y,nprev,2,3)
rf_parallel_4c=rf_parallel.rolling.window(Y,nprev,1,4)
rf_parallel_4p=rf_parallel.rolling.window(Y,nprev,2,4)
rf_parallel_5c=rf_parallel.rolling.window(Y,nprev,1,5)
rf_parallel_5p=rf_parallel.rolling.window(Y,nprev,2,5)
rf_parallel_6c=rf_parallel.rolling.window(Y,nprev,1,6)
rf_parallel_6p=rf_parallel.rolling.window(Y,nprev,2,6)
rf_parallel_7c=rf_parallel.rolling.window(Y,nprev,1,7)
rf_parallel_7p=rf_parallel.rolling.window(Y,nprev,2,7)
rf_parallel_8c=rf_parallel.rolling.window(Y,nprev,1,8)
rf_parallel_8p=rf_parallel.rolling.window(Y,nprev,2,8)
rf_parallel_9c=rf_parallel.rolling.window(Y,nprev,1,9)
rf_parallel_9p=rf_parallel.rolling.window(Y,nprev,2,9)
rf_parallel_10c=rf_parallel.rolling.window(Y,nprev,1,10)
rf_parallel_10p=rf_parallel.rolling.window(Y,nprev,2,10)
rf_parallel_11c=rf_parallel.rolling.window(Y,nprev,1,11)
rf_parallel_11p=rf_parallel.rolling.window(Y,nprev,2,11)
rf_parallel_12c=rf_parallel.rolling.window(Y,nprev,1,12)
rf_parallel_12p=rf_parallel.rolling.window(Y,nprev,2,12)


#MCS test across horizons


# 
# rf_parallel_1c$errors
# 
# rf_parallel_6c$predint_cov
# 
# cbind(tail(Y[,1],132),rf_parallel_6c$pred )

### == juntando tudo ==  ###

cpi=cbind(rf_parallel_1c$pred,rf_parallel_2c$pred,rf_parallel_3c$pred,rf_parallel_4c$pred,
          rf_parallel_5c$pred,rf_parallel_6c$pred,rf_parallel_7c$pred,rf_parallel_8c$pred,
          rf_parallel_9c$pred,rf_parallel_10c$pred,rf_parallel_11c$pred,rf_parallel_12c$pred)

pce=cbind(rf_parallel_1p$pred,rf_parallel_2p$pred,rf_parallel_3p$pred,rf_parallel_4p$pred,
          rf_parallel_5p$pred,rf_parallel_6p$pred,rf_parallel_7p$pred,rf_parallel_8p$pred,
          rf_parallel_9p$pred,rf_parallel_10p$pred,rf_parallel_11p$pred,rf_parallel_12p$pred)


##
write.table(cpi,"./results/passado2000_fixed_oldstart/rf-parallel-cpi.csv",sep=";",row.names = FALSE, col.names = FALSE)
write.table(pce,"./results/passado2000_fixed_oldstart/rf-parallel--pce.csv",sep=";",row.names = FALSE, col.names = FALSE)

#save all the results, including intervals etc
save(rf_parallel_1c,rf_parallel_2c,rf_parallel_3c,rf_parallel_4c,
     rf_parallel_5c,rf_parallel_6c,rf_parallel_7c,rf_parallel_8c,
     rf_parallel_9c,rf_parallel_10c,rf_parallel_11c,rf_parallel_12c ,
     file = "./results/passado2000_fixed_oldstart/rf-parallel-all-cpi.Rdata")


rf_cpi_list <- list(rf_parallel_1c,rf_parallel_2c,rf_parallel_3c,rf_parallel_4c,
                    rf_parallel_5c,rf_parallel_6c,rf_parallel_7c,rf_parallel_8c,
                    rf_parallel_9c,rf_parallel_10c,rf_parallel_11c,rf_parallel_12c)

save(rf_cpi_list ,file =  "./results/passado2000_fixed_oldstart/rf-parallel-list-cpi.Rdata")


rf_pce_list <- list(rf_parallel_1p,rf_parallel_2p,rf_parallel_3p,rf_parallel_4p,
                    rf_parallel_5p,rf_parallel_6p,rf_parallel_7p,rf_parallel_8p,
                    rf_parallel_9p,rf_parallel_10p,rf_parallel_11p,rf_parallel_12p)

save(rf_pce_list , file = "./results/passado2000_fixed_oldstart/rf-parallel-list-pce.Rdata")
